module Control(
	input clock, reset_n, start,
	input [15:0] dividend, divisor,
	output reg busy, error, dataValid,
	output [15:0] quotient, remainder);
	
	//Internal signals
	reg [15:0] intQuotient, intRemainder;
	reg [15:0] intDivisor;
	reg [3:0] pState;
	
	wire errorInput;
	
	localparam [3:0]
		SStart = 4'd0,
		S1 = 4'd1,
		S2 = 4'd2,
		S3 = 4'd3,
		S4 = 4'd4,
		SDone = 4'd5,
		SResult = 4'd6,
		SError = 4'd7;
		
	assign quotient = intQuotient;
	assign remainder = intRemainder;
	assign errorInput = (~|divisor)|divisor[15]|dividend[15];
	
	always @(posedge(clock) or negedge(reset_n)) begin
		if(!reset_n) begin
			intQuotient <= 0;
			intRemainder <= 0;
			busy <= 1'b0;
			error <= 1'b0;
			dataValid <= 1'b0;
			pState <= SStart;
		end else begin
			case(pState) 
				SStart:	begin
								error <= 1'b0;
								busy <= 1'b0;
								dataValid <= 1'b0;
								intQuotient <= 0;
								if(start) pState <= S1;
							end
							
				S1:	begin
							if(errorInput) pState <= SError;
							else pState <= S2;
						end
						
				S2:	begin
							intRemainder <= dividend;
							intDivisor <= divisor;
							busy <= 1'b1;
							pState <= S3;
						end
						
				S3:	begin
							if(intRemainder[15]) pState <= SDone;
							else begin
								intRemainder <= intRemainder - intDivisor;
								intQuotient <= intQuotient + 1;
							end
						end
						
				SDone:	begin
								intRemainder <= intRemainder + intDivisor;
								intQuotient <= intQuotient - 1;
								pState <= SResult;
							end
							
				SResult: begin
								dataValid <= 1'b1;
								if(!start) pState <= SStart;
							 end
							 
				SError:	begin
								error <= 1'b1;
								busy <= 1'b1;
								if(!start) pState <= SStart;
							end
			endcase
		end	
	end
	
endmodule
							